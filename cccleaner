#!/usr/bin/env bash

# Claude Code Cleaner - Clean history from ~/.claude.json
# Usage: ./cccleaner.sh [options]

set -euo pipefail

CLAUDE_JSON="$HOME/.claude.json"
CLAUDE_DIR="$HOME/.claude"
BACKUP_DIR="$HOME/.claude_backups"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if jq is installed
check_dependencies() {
    if ! command -v jq &> /dev/null; then
        print_error "jq is required but not installed. Please install it:"
        echo "  macOS: brew install jq"
        echo "  Linux: apt-get install jq or yum install jq"
        exit 1
    fi
}

# Create backup of .claude.json and .claude directory
create_backup() {
    mkdir -p "$BACKUP_DIR"
    local timestamp=$(date +%Y%m%d_%H%M%S)

    # Backup .claude.json if exists
    if [ -f "$CLAUDE_JSON" ]; then
        local backup_file="$BACKUP_DIR/claude_$(basename "$CLAUDE_JSON")_$timestamp"
        cp "$CLAUDE_JSON" "$backup_file"
        print_success "Backup created: $backup_file"
    fi

    # Backup .claude directory if exists
    if [ -d "$CLAUDE_DIR" ]; then
        local backup_dir="$BACKUP_DIR/claude_dir_$timestamp"
        cp -r "$CLAUDE_DIR" "$backup_dir"
        print_success "Backup created: $backup_dir"
    fi
}

# Show usage
show_usage() {
    cat << EOF
Claude Code Cleaner - Clean history from ~/.claude.json

Usage: $(basename "$0") [options]

Options:
    -a, --all              Clean everything (histories + projects + folders + cache + history.jsonl)
    -p, --project PATH     Clear history for specific project path
    -l, --list             List all projects
    -i, --interactive      Interactive mode to select projects
    -c, --cache            Clear cached data (changelog, etc.)
    -f, --folders          Clear ~/.claude folder contents (file-history, projects, todos, shell-snapshots, statsig, debug, history.jsonl)
    -h, --help             Show this help message
    --no-backup            Skip backup creation (not recommended)

Examples:
    $(basename "$0") --list
    $(basename "$0") --all
    $(basename "$0") --folders
    $(basename "$0") --project /Users/user/myproject
    $(basename "$0") --interactive

EOF
}

# List all projects
list_projects() {
    print_info "Projects in $CLAUDE_JSON:"
    echo
    jq -r '.projects | keys[] | "  \(.)"' "$CLAUDE_JSON" 2>/dev/null || {
        print_error "Failed to read projects from $CLAUDE_JSON"
        exit 1
    }
}

# Clear all project histories
clear_all_histories() {
    local temp_file=$(mktemp)

    jq '.projects |= with_entries(.value.history = [])' "$CLAUDE_JSON" > "$temp_file"

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$CLAUDE_JSON"
        print_success "Cleared all project histories"
    else
        rm -f "$temp_file"
        print_error "Failed to clear histories"
        exit 1
    fi
}

# Clear specific project history
clear_project_history() {
    local project_path="$1"
    local temp_file=$(mktemp)

    # Check if project exists
    if ! jq -e --arg path "$project_path" '.projects | has($path)' "$CLAUDE_JSON" > /dev/null 2>&1; then
        print_error "Project not found: $project_path"
        rm -f "$temp_file"
        exit 1
    fi

    jq --arg path "$project_path" '.projects[$path].history = []' "$CLAUDE_JSON" > "$temp_file"

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$CLAUDE_JSON"
        print_success "Cleared history for: $project_path"
    else
        rm -f "$temp_file"
        print_error "Failed to clear history for: $project_path"
        exit 1
    fi
}

# Delete specific project entirely
delete_project() {
    local project_path="$1"
    local temp_file=$(mktemp)

    # Check if project exists
    if ! jq -e --arg path "$project_path" '.projects | has($path)' "$CLAUDE_JSON" > /dev/null 2>&1; then
        print_error "Project not found: $project_path"
        rm -f "$temp_file"
        exit 1
    fi

    jq --arg path "$project_path" 'del(.projects[$path])' "$CLAUDE_JSON" > "$temp_file"

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$CLAUDE_JSON"
        print_success "Deleted project: $project_path"
    else
        rm -f "$temp_file"
        print_error "Failed to delete project: $project_path"
        exit 1
    fi
}

# Clear all projects entirely
clear_all_projects() {
    local temp_file=$(mktemp)

    jq '.projects = {}' "$CLAUDE_JSON" > "$temp_file"

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$CLAUDE_JSON"
        print_success "Cleared all projects"
    else
        rm -f "$temp_file"
        print_error "Failed to clear all projects"
        exit 1
    fi
}

# Clear cached data
clear_cache() {
    local temp_file=$(mktemp)

    jq 'del(.cachedChangelog, .cachedStatsigGates, .cachedDynamicConfigs)' "$CLAUDE_JSON" > "$temp_file"

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$CLAUDE_JSON"
        print_success "Cleared cached data"
    else
        rm -f "$temp_file"
        print_error "Failed to clear cache"
        exit 1
    fi
}

# Clear ~/.claude folder contents
clear_claude_folders() {
    local cleaned=0

    # Clear file-history
    if [ -d "$CLAUDE_DIR/file-history" ]; then
        rm -rf "$CLAUDE_DIR/file-history"/*
        print_success "Cleared file-history"
        cleaned=1
    fi

    # Clear projects
    if [ -d "$CLAUDE_DIR/projects" ]; then
        rm -rf "$CLAUDE_DIR/projects"/*
        print_success "Cleared projects"
        cleaned=1
    fi

    # Clear todos
    if [ -d "$CLAUDE_DIR/todos" ]; then
        rm -rf "$CLAUDE_DIR/todos"/*
        print_success "Cleared todos"
        cleaned=1
    fi

    # Clear shell-snapshots
    if [ -d "$CLAUDE_DIR/shell-snapshots" ]; then
        rm -rf "$CLAUDE_DIR/shell-snapshots"/*
        print_success "Cleared shell-snapshots"
        cleaned=1
    fi

    # Clear statsig
    if [ -d "$CLAUDE_DIR/statsig" ]; then
        rm -rf "$CLAUDE_DIR/statsig"/*
        print_success "Cleared statsig"
        cleaned=1
    fi

    # Clear debug
    if [ -d "$CLAUDE_DIR/debug" ]; then
        rm -rf "$CLAUDE_DIR/debug"/*
        print_success "Cleared debug"
        cleaned=1
    fi

    if [ $cleaned -eq 0 ]; then
        print_warning "No folders found to clean"
    fi
}

# Clear history.jsonl
clear_history_jsonl() {
    if [ -f "$CLAUDE_DIR/history.jsonl" ]; then
        > "$CLAUDE_DIR/history.jsonl"
        print_success "Cleared history.jsonl"
    else
        print_warning "history.jsonl not found"
    fi
}

# Clean everything
clean_all() {
    print_info "Performing deep clean..."
    echo

    clear_all_histories
    clear_all_projects
    clear_claude_folders
    clear_cache
    clear_history_jsonl

    print_success "Deep clean completed!"
}

# Interactive mode
interactive_mode() {
    print_info "Interactive Mode - Select projects to clean"
    echo

    # Get project list
    local projects=($(jq -r '.projects | keys[]' "$CLAUDE_JSON"))

    if [ ${#projects[@]} -eq 0 ]; then
        print_warning "No projects found"
        exit 0
    fi

    echo "Projects:"
    for i in "${!projects[@]}"; do
        local project="${projects[$i]}"
        local history_count=$(jq -r --arg path "$project" '.projects[$path].history | length' "$CLAUDE_JSON")
        echo "  [$((i+1))] $project (${history_count} history items)"
    done
    echo
    echo "Options:"
    echo "  [a] Clean everything"
    echo "  [c] Clear cache"
    echo "  [f] Clear folders (file-history, projects, todos, shell-snapshots, statsig, debug, history.jsonl)"
    echo "  [q] Quit"
    echo
    read -p "Enter selection (number/a/c/f/q): " selection

    case "$selection" in
        a|A)
            read -p "Clean everything? (y/N): " confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                clean_all
            else
                print_info "Cancelled"
            fi
            ;;
        c|C)
            read -p "Clear cached data? (y/N): " confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                clear_cache
            else
                print_info "Cancelled"
            fi
            ;;
        f|F)
            read -p "Clear ~/.claude folders? (y/N): " confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                clear_claude_folders
                clear_history_jsonl
            else
                print_info "Cancelled"
            fi
            ;;
        q|Q)
            print_info "Exiting"
            exit 0
            ;;
        [0-9]*)
            if [ "$selection" -ge 1 ] && [ "$selection" -le "${#projects[@]}" ]; then
                local project="${projects[$((selection-1))]}"
                echo
                echo "What would you like to do with: $project"
                echo "  [1] Clear history only"
                echo "  [2] Delete project entirely"
                echo "  [q] Cancel"
                read -p "Enter selection: " action

                case "$action" in
                    1)
                        clear_project_history "$project"
                        ;;
                    2)
                        read -p "Delete project entirely? (y/N): " confirm
                        if [[ "$confirm" =~ ^[Yy]$ ]]; then
                            delete_project "$project"
                        else
                            print_info "Cancelled"
                        fi
                        ;;
                    *)
                        print_info "Cancelled"
                        ;;
                esac
            else
                print_error "Invalid selection"
                exit 1
            fi
            ;;
        *)
            print_error "Invalid selection"
            exit 1
            ;;
    esac
}

# Main function
main() {
    local create_backup_flag=true
    local action=""
    local project_path=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -l|--list)
                check_dependencies
                list_projects
                exit 0
                ;;
            -a|--all)
                action="clear_all"
                shift
                ;;
            -p|--project)
                action="clear_project"
                project_path="$2"
                shift 2
                ;;
            -i|--interactive)
                action="interactive"
                shift
                ;;
            -c|--cache)
                action="clear_cache"
                shift
                ;;
            -f|--folders)
                action="clear_folders"
                shift
                ;;
            --no-backup)
                create_backup_flag=false
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Check dependencies
    check_dependencies

    # If no action specified, show usage
    if [ -z "$action" ]; then
        show_usage
        exit 0
    fi

    # Create backup unless disabled
    if [ "$create_backup_flag" = true ]; then
        create_backup
        echo
    fi

    # Execute action
    case "$action" in
        clear_all)
            clean_all
            ;;
        clear_project)
            if [ -z "$project_path" ]; then
                print_error "Project path is required"
                exit 1
            fi
            clear_project_history "$project_path"
            ;;
        interactive)
            interactive_mode
            ;;
        clear_cache)
            clear_cache
            ;;
        clear_folders)
            clear_claude_folders
            clear_history_jsonl
            ;;
        *)
            print_error "Unknown action: $action"
            exit 1
            ;;
    esac

    # Don't print "Done!" for clear_all as it has its own message
    if [ "$action" != "clear_all" ]; then
        print_success "Done!"
    fi
}

# Run main function
main "$@"
